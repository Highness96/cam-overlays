<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tip Wheel Overlay (High-End)</title>

<style>
:root{
  --panel-bg: rgba(10, 8, 20, 0.42);
  --panel-border: rgba(180, 120, 255, 0.42);
  --panel-edge: rgba(110, 231, 255, 0.22);

  --deep-purple: rgba(52, 16, 82, 0.98);
  --neon-violet: rgba(186, 99, 255, 0.98);
  --soft-cyan: rgba(110, 231, 255, 0.98);
  --midnight: rgba(10, 12, 30, 0.98);

  --text: rgba(245, 245, 255, 0.95);
  --text-stroke: rgba(10, 12, 30, 0.72);
  --glow-violet: rgba(186, 99, 255, 0.55);
  --glow-cyan: rgba(110, 231, 255, 0.55);

  --glass: rgba(255,255,255,0.08);
  --glass2: rgba(255,255,255,0.03);
}

html, body{
  margin:0;
  padding:0;
  background: transparent; /* OBS */
  overflow:hidden;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Helvetica Neue", Helvetica, sans-serif;
  color: var(--text);
}

/* OBS positioning (keep your original placement) */
#wrap{
  position:absolute;
  right:40px;
  bottom:40px;
  width:900px;
  height:900px;
  pointer-events:none;
}

#panel{
  position:absolute;
  inset:0;
  border-radius:28px;
  background: linear-gradient(180deg, rgba(10,8,20,0.30), rgba(10,8,20,0.18));
  border: 1px solid rgba(180, 120, 255, 0.24);
  box-shadow:
    0 18px 60px rgba(0,0,0,0.35),
    0 0 60px rgba(186,99,255,0.16),
    0 0 90px rgba(110,231,255,0.10);
  backdrop-filter: blur(10px);
}

/* subtle glossy sweep */
#panel::before{
  content:"";
  position:absolute;
  inset:10px;
  border-radius:22px;
  background: radial-gradient(120% 70% at 20% 10%, rgba(255,255,255,0.10), rgba(255,255,255,0.00) 55%),
              radial-gradient(120% 70% at 80% 0%, rgba(110,231,255,0.06), rgba(255,255,255,0.00) 60%);
  pointer-events:none;
}

#panel::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius:28px;
  border: 1px solid rgba(110,231,255,0.16);
  pointer-events:none;
}

#header{
  position:absolute;
  top:18px;
  left:24px;
  right:24px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  pointer-events:none;
}

#title{
  font-size:28px;
  font-weight:900;
  letter-spacing:0.6px;
  text-shadow: 0 0 14px rgba(186,99,255,0.20);
}

#cost{
  font-size:18px;
  padding:10px 14px;
  border-radius:999px;
  background: rgba(10,12,30,0.42);
  border:1px solid rgba(186,99,255,0.22);
  box-shadow: 0 0 22px rgba(110,231,255,0.10);
}

/* Clean glowing pointer (SVG for crisp 4K) */
#pointer{
  position:absolute;
  top:104px;
  left:50%;
  transform:translateX(-50%);
  width:88px;
  height:88px;
  pointer-events:none;
  filter: drop-shadow(0 0 14px rgba(110,231,255,0.35))
          drop-shadow(0 0 22px rgba(186,99,255,0.25));
}

#canvas{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%, -50%);
  width:780px;
  height:780px;
}

/* Click target only if you enable click-to-spin */
#spinHit{
  position:absolute;
  left:50%;
  top:56%;
  transform:translate(-50%, -50%);
  width:260px;
  height:260px;
  border-radius:50%;
  pointer-events:auto;
  background: transparent;
  display:none; /* turned on in JS if CLICK_TO_SPIN */
}

#result{
  position:absolute;
  left:24px;
  right:24px;
  bottom:24px;
  padding:18px 20px;
  font-size:20px;
  border-radius:18px;
  background: rgba(10,12,30,0.42);
  border: 1px solid rgba(186,99,255,0.18);
  box-shadow:
    0 0 24px rgba(186,99,255,0.10),
    0 0 18px rgba(110,231,255,0.06);
  display:flex;
  justify-content:space-between;
  gap:16px;
  pointer-events:none;
}

.flash{
  animation: flash 0.9s ease-out;
}
@keyframes flash{
  0%   { box-shadow: 0 18px 60px rgba(0,0,0,0.35), 0 0 0 rgba(0,0,0,0); }
  30%  { box-shadow: 0 18px 60px rgba(0,0,0,0.35), 0 0 120px rgba(186,99,255,0.35), 0 0 140px rgba(110,231,255,0.20); }
  100% { box-shadow: 0 18px 60px rgba(0,0,0,0.35), 0 0 60px rgba(186,99,255,0.16), 0 0 90px rgba(110,231,255,0.10); }
}
</style>
</head>

<body>
<div id="wrap">
  <div id="panel"></div>

  <div id="header">
    <div id="title">TIP WHEEL</div>
    <div id="cost">Spin: <span id="spinCost">100</span> tokens</div>
  </div>

  <!-- SVG pointer for crisp edges -->
  <svg id="pointer" viewBox="0 0 100 100" aria-hidden="true">
    <defs>
      <linearGradient id="pg" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0" stop-color="rgba(110,231,255,0.95)"/>
        <stop offset="1" stop-color="rgba(186,99,255,0.95)"/>
      </linearGradient>
    </defs>
    <path d="M50 6
             C58 18, 70 28, 90 35
             C70 39, 58 52, 50 74
             C42 52, 30 39, 10 35
             C30 28, 42 18, 50 6Z"
          fill="url(#pg)" opacity="0.98"/>
    <path d="M50 14
             C56 24, 65 30, 78 35
             C65 38, 56 48, 50 64
             C44 48, 35 38, 22 35
             C35 30, 44 24, 50 14Z"
          fill="rgba(10,12,30,0.30)"/>
  </svg>

  <canvas id="canvas" width="780" height="780"></canvas>
  <div id="spinHit" title="Click SPIN"></div>

  <div id="result">
    <div>Result: <b id="lastResult">—</b></div>
    <div id="lastTip" style="opacity:.75; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:420px;">waiting for tip…</div>
  </div>
</div>

<!-- AUDIO -->
<audio id="soundTip"  src="audio/tip.wav" preload="auto"></audio>
<audio id="soundSpin" src="audio/spin.wav" preload="auto"></audio>
<audio id="soundWin"  src="audio/win.wav" preload="auto"></audio>

<script>
/* ================= CONFIG ================= */
const SPIN_COST = 100;

// Optional: allow clicking the center SPIN button in OBS (requires OBS Browser Source "Interact")
const CLICK_TO_SPIN = false;

const ITEMS = [
  "Pull pants down",
  "Flash anything (5 sec)",
  "Show feet",
  "I choose",
  "Grab my package",
  "Chat chooses",
  "Spin again",
  "VIP attention"
];

document.getElementById("spinCost").textContent = SPIN_COST;

/* ================= AUDIO ================= */
const soundTip  = document.getElementById("soundTip");
const soundSpin = document.getElementById("soundSpin");
const soundWin  = document.getElementById("soundWin");

function playSound(a){
  try{
    a.pause();
    a.currentTime = 0;
    a.play().catch(()=>{});
  }catch(e){}
}

/* ================= CANVAS (CRISP 1080p/4K) ================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { alpha:true });

function setupDPR(){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  canvas.width  = Math.round(rect.width  * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
setupDPR();
window.addEventListener("resize", setupDPR);

/* ================= DOM ================= */
const panel = document.getElementById("panel");
const lastResult = document.getElementById("lastResult");
const lastTip = document.getElementById("lastTip");
const spinHit = document.getElementById("spinHit");

if (CLICK_TO_SPIN){
  spinHit.style.display = "block";
  // Your wrap has pointer-events:none; enable pointer events only on the hit area
  document.getElementById("wrap").style.pointerEvents = "none";
  spinHit.style.pointerEvents = "auto";
}

/* ================= WHEEL STATE ================= */
let angle = 0;
let spinning = false;

// Premium spin curve (time-based, no jitter)
let spinStart = 0;
let spinFrom = 0;
let spinTo = 0;
const SPIN_DURATION = 5200;

// Ease out quart
function easeOutQuart(t){ return 1 - Math.pow(1 - t, 4); }

/* ================= VISUAL HELPERS ================= */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function sliceColors(i){
  const palette = [
    ["rgba(52,16,82,0.98)",  "rgba(186,99,255,0.98)"],
    ["rgba(10,12,30,0.98)",  "rgba(110,231,255,0.98)"],
    ["rgba(26,14,64,0.98)",  "rgba(186,99,255,0.98)"],
    ["rgba(12,18,48,0.98)",  "rgba(110,231,255,0.98)"]
  ];
  return palette[i % palette.length];
}

function measureTextWidth(text, font){
  ctx.save();
  ctx.font = font;
  const w = ctx.measureText(text).width;
  ctx.restore();
  return w;
}

function wrapTwoLines(text){
  const words = text.trim().split(/\s+/).filter(Boolean);
  if (words.length <= 1) return [text];

  // pick best 2-line split with smallest max width
  const baseFont = ctx.font;
  let best = null;

  for (let cut=1; cut<words.length; cut++){
    const a = words.slice(0,cut).join(" ");
    const b = words.slice(cut).join(" ");
    const wa = ctx.measureText(a).width;
    const wb = ctx.measureText(b).width;
    const worst = Math.max(wa, wb);
    if (!best || worst < best.worst) best = { a, b, worst };
  }

  ctx.font = baseFont;
  return best ? [best.a, best.b] : [text];
}

function drawTextOnArc(text, centerAngle, radius, maxArcPx, maxSizePx){
  // Bold, modern, readable
  const TAU = Math.PI * 2;

  // Normalize angle to [0, 2π)
  let aNorm = centerAngle % TAU;
  if (aNorm < 0) aNorm += TAU;

  // Bottom half of wheel in canvas coords: (0..π) is bottom (because +Y is down)
  const isBottom = (aNorm > 0 && aNorm < Math.PI);

  // Fit font size (1-line first)
  let size = maxSizePx;
  const minSize = Math.max(12, Math.floor(maxSizePx * 0.62));

  for (; size >= minSize; size--){
    ctx.font = `900 ${size}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    if (ctx.measureText(text).width <= maxArcPx) break;
  }

  ctx.font = `900 ${size}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;

  // If still too wide, try two-line split
  let lines = [text];
  if (ctx.measureText(text).width > maxArcPx){
    lines = wrapTwoLines(text); // uses your existing helper
  }

  const lineGap = Math.max(10, size * 0.90);
  const startRadius = lines.length === 2 ? (radius - lineGap * 0.40) : radius;

  lines.forEach((line, idx) => {
    const rLine = startRadius + idx * lineGap * 0.72;

    // Build glyph widths
    let chars = [...line];
    let widths = chars.map(ch => ctx.measureText(ch).width);

    // Total pixel width → arc span
    const totalPx = widths.reduce((a,b)=>a+b,0);
    const arcPx = Math.min(maxArcPx, totalPx);
    const span = arcPx / rLine;

    // We draw centered on centerAngle
    const start = centerAngle - span/2;

    // Flip logic:
    // If bottom half: reverse characters and walk angles backwards so it reads left→right.
    if (isBottom){
      chars = chars.reverse();
      widths = widths.reverse();
    }

    ctx.save();
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    // outline + subtle glow
    ctx.shadowColor = "rgba(186,99,255,0.22)";
    ctx.shadowBlur = Math.max(6, size * 0.45);
    ctx.fillStyle = "rgba(245,245,255,0.95)";
    ctx.strokeStyle = "rgba(10,12,30,0.72)";
    ctx.lineWidth = Math.max(2, size * 0.10);

    if (!isBottom){
      // Top half: move forward
      let ang = start;
      for (let i=0;i<chars.length;i++){
        const ch = chars[i];
        const chA = widths[i] / rLine;
        const mid = ang + chA/2;

        ctx.save();
        ctx.rotate(mid);
        ctx.translate(0, -rLine);
        ctx.rotate(Math.PI/2);          // tangent, upright
        ctx.strokeText(ch, 0, 0);
        ctx.fillText(ch, 0, 0);
        ctx.restore();

        ang += chA;
      }
    } else {
      // Bottom half: walk backward (and reverse chars) to keep readable
      let ang = start + span;
      for (let i=0;i<chars.length;i++){
        const ch = chars[i];
        const chA = widths[i] / rLine;
        const mid = ang - chA/2;

        ctx.save();
        ctx.rotate(mid);
        ctx.tra

/* ================= DRAW (HIGH-END) ================= */
function drawWheel(){
  const rect = canvas.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  const cx = W/2, cy = H/2;
  const R = Math.min(cx, cy) * 0.93;

  ctx.clearRect(0,0,W,H);

  // soft shadow under wheel (depth)
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy + R*0.06, R*0.98, 0, Math.PI*2);
  ctx.fillStyle = "rgba(0,0,0,0.10)";
  ctx.filter = "blur(14px)";
  ctx.fill();
  ctx.restore();

  const n = ITEMS.length;
  const slice = Math.PI*2 / n;

  // slices
  for (let i=0;i<n;i++){
    const a0 = angle + i*slice;
    const a1 = a0 + slice;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,R,a0,a1);
    ctx.closePath();

    // smooth gradients (conic when available)
    let fill;
    if (typeof ctx.createConicGradient === "function"){
      const mid = (a0+a1)/2;
      fill = ctx.createConicGradient(mid, cx, cy);
      const [cA, cB] = sliceColors(i);
      fill.addColorStop(0.00, cA);
      fill.addColorStop(0.40, "rgba(26,14,64,0.98)");
      fill.addColorStop(0.72, cB);
      fill.addColorStop(1.00, cA);
    }else{
      const [cA, cB] = sliceColors(i);
      fill = ctx.createRadialGradient(cx,cy,R*0.10,cx,cy,R);
      fill.addColorStop(0, cB);
      fill.addColorStop(1, cA);
    }
    ctx.fillStyle = fill;
    ctx.fill();

    // glass sheen
    const sheen = ctx.createRadialGradient(cx - R*0.25, cy - R*0.35, R*0.12, cx, cy, R);
    sheen.addColorStop(0.00, "rgba(255,255,255,0.18)");
    sheen.addColorStop(0.25, "rgba(255,255,255,0.08)");
    sheen.addColorStop(0.55, "rgba(255,255,255,0.00)");
    sheen.addColorStop(1.00, "rgba(255,255,255,0.00)");
    ctx.fillStyle = sheen;
    ctx.globalCompositeOperation = "screen";
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";

    // vignette for depth
    const vign = ctx.createRadialGradient(cx,cy,R*0.25,cx,cy,R);
    vign.addColorStop(0.0, "rgba(0,0,0,0.00)");
    vign.addColorStop(1.0, "rgba(0,0,0,0.22)");
    ctx.fillStyle = vign;
    ctx.fill();

    ctx.restore();
  }

  // glowing dividers (thin, premium)
  ctx.save();
  ctx.lineWidth = Math.max(1.2, R*0.006);
  ctx.strokeStyle = "rgba(120,245,255,0.22)";
  ctx.shadowColor = "rgba(120,245,255,0.55)";
  ctx.shadowBlur = Math.max(10, R*0.05);

  for (let i=0;i<n;i++){
    const a = angle + i*slice;
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.lineTo(cx + Math.cos(a)*R, cy + Math.sin(a)*R);
    ctx.stroke();
  }
  ctx.restore();

  // outer rim (crisp edge + faint neon)
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx,cy,R,0,Math.PI*2);
  ctx.lineWidth = Math.max(2, R*0.020);
  ctx.strokeStyle = "rgba(10,12,30,0.55)";
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(cx,cy,R,0,Math.PI*2);
  ctx.lineWidth = Math.max(2, R*0.012);
  ctx.shadowColor = "rgba(186,99,255,0.55)";
  ctx.shadowBlur = Math.max(12, R*0.06);
  ctx.strokeStyle = "rgba(186,99,255,0.22)";
  ctx.stroke();
  ctx.restore();

  // text: curved, centered, auto-size, never touching edges
  const textRadius = R * 0.72;
  const maxArcPx = (slice * textRadius) * 0.86;
  const maxSize = Math.floor(clamp(R*0.070, 16, 40));

  for (let i=0;i<n;i++){
    const mid = angle + (i+0.5)*slice;
    ctx.save();
    ctx.translate(cx,cy);
    drawTextOnArc(ITEMS[i], mid, textRadius, maxArcPx, maxSize);
    ctx.restore();
  }

  // center hub
  const hubR = R * 0.22;
  const btnR = R * 0.15;

  ctx.save();
  ctx.translate(cx,cy);

  // hub base
  ctx.beginPath();
  ctx.arc(0,0,hubR,0,Math.PI*2);
  const hubGrad = ctx.createRadialGradient(-hubR*0.25,-hubR*0.35,hubR*0.12,0,0,hubR);
  hubGrad.addColorStop(0.00, "rgba(55,18,90,0.95)");
  hubGrad.addColorStop(0.60, "rgba(10,12,30,0.92)");
  hubGrad.addColorStop(1.00, "rgba(0,0,0,0.82)");
  ctx.fillStyle = hubGrad;
  ctx.fill();

  // hub ring glow
  ctx.lineWidth = Math.max(2, R*0.008);
  ctx.shadowColor = "rgba(110,231,255,0.28)";
  ctx.shadowBlur = Math.max(10, R*0.05);
  ctx.strokeStyle = "rgba(110,231,255,0.16)";
  ctx.stroke();

  // button (raised, metallic/glass)
  ctx.shadowBlur = 0;
  ctx.beginPath();
  ctx.arc(0,0,btnR,0,Math.PI*2);
  const btnGrad = ctx.createLinearGradient(-btnR, -btnR, btnR, btnR);
  btnGrad.addColorStop(0.00, "rgba(110,231,255,0.22)");
  btnGrad.addColorStop(0.35, "rgba(186,99,255,0.28)");
  btnGrad.addColorStop(0.72, "rgba(10,12,30,0.55)");
  btnGrad.addColorStop(1.00, "rgba(0,0,0,0.68)");
  ctx.fillStyle = btnGrad;
  ctx.shadowColor = "rgba(0,0,0,0.55)";
  ctx.shadowBlur = Math.max(10, R*0.04);
  ctx.shadowOffsetY = Math.max(2, R*0.010);
  ctx.fill();

  // highlight
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
  ctx.beginPath();
  ctx.arc(-btnR*0.22,-btnR*0.25,btnR*0.62,0,Math.PI*2);
  const hi = ctx.createRadialGradient(-btnR*0.25,-btnR*0.35,btnR*0.05,0,0,btnR);
  hi.addColorStop(0.0, "rgba(255,255,255,0.20)");
  hi.addColorStop(0.4, "rgba(255,255,255,0.08)");
  hi.addColorStop(1.0, "rgba(255,255,255,0.00)");
  ctx.fillStyle = hi;
  ctx.globalCompositeOperation = "screen";
  ctx.fill();
  ctx.globalCompositeOperation = "source-over";

  // button neon edge
  ctx.beginPath();
  ctx.arc(0,0,btnR,0,Math.PI*2);
  ctx.lineWidth = Math.max(2, R*0.006);
  ctx.shadowColor = "rgba(186,99,255,0.45)";
  ctx.shadowBlur = Math.max(12, R*0.06);
  ctx.strokeStyle = "rgba(186,99,255,0.24)";
  ctx.stroke();

  // SPIN label
  const spinFont = Math.max(18, Math.floor(btnR * 0.56));
  ctx.font = `900 ${spinFont}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.shadowColor = "rgba(110,231,255,0.22)";
  ctx.shadowBlur = Math.max(8, R*0.03);
  ctx.fillStyle = "rgba(245,245,255,0.95)";
  ctx.strokeStyle = "rgba(10,12,30,0.72)";
  ctx.lineWidth = Math.max(2, spinFont * 0.10);
  ctx.strokeText("SPIN", 0, 0);
  ctx.fillText("SPIN", 0, 0);

  ctx.restore(); // translate(cx,cy)
}

/* ================= WINNER / POINTER ================= */
/* Pointer is at TOP. Determine slice under pointer for final result. */
function getWinnerIndex(){
  const n = ITEMS.length;
  const slice = Math.PI*2 / n;
  const pointerAngle = -Math.PI/2;

  // Map pointer into wheel space
  let a = (pointerAngle - angle) % (Math.PI*2);
  if (a < 0) a += Math.PI*2;

  return Math.floor(a / slice);
}

/* ================= SPIN (TIME-BASED PREMIUM) ================= */
function spin(user, amount){
  if (spinning) return;
  spinning = true;

  playSound(soundSpin);
  panel.classList.remove("flash");
  void panel.offsetWidth;
  panel.classList.add("flash");

  lastTip.textContent = `Tip ${amount} by ${user}`;

  // Choose a random target winner (uniform)
  const target = Math.floor(Math.random() * ITEMS.length);

  const n = ITEMS.length;
  const slice = Math.PI*2 / n;
  const pointerAngle = -Math.PI/2;
  const targetCenter = (target + 0.5) * slice;

  // We want: pointerAngle - finalAngle == targetCenter (mod 2PI)
  const desired = pointerAngle - targetCenter;

  // Add multiple full rotations for drama (no jitter)
  const turns = (Math.random() * 3 + 5.5) * (Math.PI*2);

  // Make final angle approach desired going forward
  const current = ((angle % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);
  const desiredNorm = ((desired % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);
  let delta = desiredNorm - current;
  if (delta < 0) delta += Math.PI*2;

  spinFrom = angle;
  spinTo = angle + turns + delta;
  spinStart = performance.now();

  function frame(now){
    const t = (now - spinStart) / SPIN_DURATION;
    if (t >= 1){
      angle = spinTo;
      drawWheel();

      const idx = getWinnerIndex();
      lastResult.textContent = ITEMS[idx];
      playSound(soundWin);

      spinning = false;
      return;
    }

    const e = easeOutQuart(clamp(t, 0, 1));
    angle = spinFrom + (spinTo - spinFrom) * e;
    drawWheel();
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

/* ================= TIP HANDLING (UNCHANGED) ================= */
function handleTip(data){
  if(!data || data.type!=="tip") return;
  playSound(soundTip);
  if(data.amount >= SPIN_COST){
    spin(data.user||"anon", data.amount);
  }
}

window.addEventListener("message", e => handleTip(e.data));

try{
  const bc = new BroadcastChannel("cb-overlays");
  bc.onmessage = e => handleTip(e.data);
}catch(e){}

/* Click-to-spin (optional) */
spinHit.addEventListener("click", (e) => {
  if (!CLICK_TO_SPIN) return;
  spin("click", SPIN_COST);
});

/* ================= START ================= */
drawWheel();
</script>
</body>
</html>

